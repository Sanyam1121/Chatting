<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Only For Her - WhatsApp Style Chat</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@joeattardi/emoji-button@4.6.2/dist/index.min.js"></script>
  <style>
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-thumb {
      background-color: rgba(100, 116, 139, 0.5);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background-color: rgba(100, 116, 139, 0.8);
    }
    /* For voice record button animation */
    .recording {
      animation: pulse 1s infinite alternate;
    }
    @keyframes pulse {
      0% { box-shadow: 0 0 6px #dc2626; }
      100% { box-shadow: 0 0 16px #b91c1c; }
    }
  </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 flex h-screen select-none transition-colors duration-500">

  <!-- LOGIN SCREEN -->
  <div id="login-section" class="m-auto max-w-sm w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8">
    <h1 class="text-2xl font-semibold mb-6 text-center">Welcome to Only For Her</h1>
    <input id="username-input" type="text" placeholder="Enter your name" 
      class="w-full border border-gray-300 rounded-lg p-3 mb-5 text-gray-900 dark:text-gray-100 dark:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500" />
    <button id="login-btn" class="w-full bg-green-600 hover:bg-green-700 transition-colors text-white font-semibold py-3 rounded-lg shadow-md">Join Chat</button>
  </div>

  <!-- CHAT APP -->
  <div id="chat-ui" class="hidden flex flex-1 max-w-7xl mx-auto bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">

    <!-- LEFT SIDEBAR: Groups/Chats -->
    <div id="groupsPage" class="w-80 flex flex-col border-r border-gray-300 dark:border-gray-700">
      <header class="flex items-center justify-between px-5 py-4 border-b border-gray-300 dark:border-gray-700">
        <h2 class="text-xl font-bold">Groups</h2>
        <span id="currentUserLabel" class="text-sm italic text-gray-500 dark:text-gray-400"></span>
      </header>

      <div id="groupsList" class="flex-1 overflow-y-auto p-4 space-y-2 bg-gray-100 dark:bg-gray-900">
        <!-- Groups will load here -->
      </div>

      <div class="p-4 border-t border-gray-300 dark:border-gray-700 flex gap-2">
        <input id="newGroupName" type="text" placeholder="New group name" 
          class="flex-1 border border-gray-300 dark:border-gray-700 rounded-lg p-2 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-green-500" />
        <button onclick="createGroup()" 
          class="bg-green-600 hover:bg-green-700 text-white font-semibold px-4 rounded-lg shadow-md transition-colors">Create</button>
      </div>
      <div class="p-3 border-t border-gray-300 dark:border-gray-700 flex items-center justify-between gap-4">
        <label for="darkModeToggle" class="cursor-pointer select-none text-gray-700 dark:text-gray-300 flex items-center gap-2">
          <input type="checkbox" id="darkModeToggle" class="hidden" />
          <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" >
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M12 3v1m0 16v1m8.66-12.34l-.7.7m-14.9 0l-.7-.7M21 12h-1M4 12H3m16.66 4.34l-.7-.7m-14.9 0l-.7.7M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
          </svg>
          <span>Dark Mode</span>
        </label>
      </div>
    </div>

    <!-- RIGHT MAIN CHAT AREA -->
    <div id="chatPage" class="hidden flex flex-col flex-1 bg-white dark:bg-gray-900">
      <!-- Chat header -->
      <header class="flex items-center justify-between border-b border-gray-300 dark:border-gray-700 px-6 py-3 bg-gray-50 dark:bg-gray-800 shadow-sm">
        <button onclick="backToGroups()" class="text-blue-600 dark:text-blue-400 font-semibold hover:underline">‚Üê Back</button>
        <h2 id="groupTitle" class="text-lg font-semibold truncate max-w-xs"></h2>
        <div id="typingIndicator" class="text-sm italic text-gray-600 dark:text-gray-400"></div>
      </header>

      <!-- Messages list -->
      <div id="messages" class="flex-1 p-6 overflow-y-auto space-y-3 bg-gray-50 dark:bg-gray-900 scrollbar-thin scrollbar-thumb-gray-400 dark:scrollbar-thumb-gray-700 flex flex-col">
        <!-- Messages appended here -->
      </div>

      <!-- Message input area -->
      <footer class="flex items-center gap-3 px-6 py-4 border-t border-gray-300 dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
        <button id="emojiBtn" class="text-2xl hover:bg-gray-200 dark:hover:bg-gray-700 p-2 rounded-full transition"><span>üòä</span></button>
        <input
          id="messageInput"
          type="text"
          placeholder="Type a message"
          autocomplete="off"
          class="flex-1 bg-white dark:bg-gray-900 border border-gray-300 dark:border-gray-700 rounded-full py-2 px-4 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
          onkeydown="if(event.key==='Enter'){sendMessage();}"
        />
        <input type="file" id="imageInput" accept="image/*" onchange="previewImage(event)" class="hidden" />
        <button onclick="document.getElementById('imageInput').click()" 
          class="text-xl hover:bg-gray-200 dark:hover:bg-gray-700 p-2 rounded-full transition" title="Send Image">üì∑</button>

        <button id="recordBtn" title="Record Voice Note" class="text-red-600 hover:bg-red-100 dark:hover:bg-red-900 p-2 rounded-full transition">
          üé§
        </button>

        <button onclick="sendMessage()" 
          class="bg-blue-600 hover:bg-blue-700 text-white font-semibold px-5 py-2 rounded-full shadow-md transition">Send</button>
      </footer>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore,
      collection,
      addDoc,
      onSnapshot,
      query,
      orderBy,
      doc,
      getDocs,
      deleteDoc,
      updateDoc,
      serverTimestamp,
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
    import {
      getStorage,
      ref,
      uploadBytes,
      getDownloadURL,
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyDuGHDotdc-EZRxyyJLrWXyLsi2dLhSHm4",
      authDomain: "chatting-fd641.firebaseapp.com",
      projectId: "chatting-fd641",
      storageBucket: "chatting-fd641.appspot.com",
      messagingSenderId: "535384451291",
      appId: "1:535384451291:web:828f60686d81be018b44fe",
      measurementId: "G-RKS4CFZPJ4",
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const storage = getStorage(app);

    // User and chat state
    let currentUser = null;
    let selectedImage = null;
    let currentGroupId = null;
    let messagesListener = null;
    let typingTimeout = null;
    let mediaRecorder = null;
    let recordedChunks = [];

    // Elements
    const loginSection = document.getElementById("login-section");
    const chatUI = document.getElementById("chat-ui");
    const groupsList = document.getElementById("groupsList");
    const currentUserLabel = document.getElementById("currentUserLabel");
    const groupTitle = document.getElementById("groupTitle");
    const messagesList = document.getElementById("messages");
    const typingIndicator = document.getElementById("typingIndicator");
    const messageInput = document.getElementById("messageInput");
    const emojiBtn = document.getElementById("emojiBtn");
    const darkModeToggle = document.getElementById("darkModeToggle");
    const recordBtn = document.getElementById("recordBtn");

    // Emoji picker setup
    const picker = new EmojiButton({
      position: 'top-start',
      theme: 'auto',
      autoHide: true,
    });
    emojiBtn.addEventListener("click", () => picker.togglePicker(emojiBtn));
    picker.on("emoji", emoji => {
      messageInput.value += emoji;
      messageInput.focus();
      updateTypingStatus(true);
    });

    // Dark mode sync and toggle
    function initDarkMode() {
      const saved = localStorage.getItem("darkMode");
      const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
      if (saved === "true" || (saved === null && prefersDark)) {
        document.documentElement.classList.add("dark");
        darkModeToggle.checked = true;
      }
      darkModeToggle.addEventListener("change", () => {
        if (darkModeToggle.checked) {
          document.documentElement.classList.add("dark");
          localStorage.setItem("darkMode", "true");
        } else {
          document.documentElement.classList.remove("dark");
          localStorage.setItem("darkMode", "false");
        }
      });
    }
    initDarkMode();

    // Login function
    document.getElementById("login-btn").addEventListener("click", () => {
      const name = document.getElementById("username-input").value.trim();
      if (!name) {
        alert("Please enter your name");
        return;
      }
      // Create simple user object
      currentUser = {
        uid: `user_${Date.now()}`,
        displayName: name,
      };
      currentUserLabel.textContent = `You: ${name}`;
      loginSection.classList.add("hidden");
      chatUI.classList.remove("hidden");
      loadGroups();
    });

    // Load groups from firestore
    async function loadGroups() {
      groupsList.innerHTML = "";
      const groupsSnap = await getDocs(collection(db, "groups"));
      groupsSnap.forEach(docSnap => {
        const group = docSnap.data();
        const groupId = docSnap.id;
        const div = document.createElement("div");
        div.textContent = group.name;
        div.className = "cursor-pointer p-3 rounded-lg hover:bg-green-100 dark:hover:bg-green-900 transition";
        div.onclick = () => openGroup(groupId, group.name);
        groupsList.appendChild(div);
      });
    }

    // Create new group
    async function createGroup() {
      const nameInput = document.getElementById("newGroupName");
      const name = nameInput.value.trim();
      if (!name) return alert("Group name cannot be empty");
      await addDoc(collection(db, "groups"), { name });
      nameInput.value = "";
      loadGroups();
    }

    // Open a group chat
    async function openGroup(groupId, groupName) {
      currentGroupId = groupId;
      groupTitle.textContent = groupName;
      document.getElementById("groupsPage").classList.add("hidden");
      document.getElementById("chatPage").classList.remove("hidden");
      messagesList.innerHTML = "";

      // Unsubscribe previous listener if any
      if (messagesListener) messagesListener();

      // Listen to messages
      const messagesRef = collection(db, "groups", groupId, "messages");
      const q = query(messagesRef, orderBy("createdAt", "asc"));

      messagesListener = onSnapshot(q, async (snapshot) => {
        messagesList.innerHTML = "";
        let lastMessageIds = [];
        snapshot.forEach(docSnap => {
          const msg = docSnap.data();
          const id = docSnap.id;
          lastMessageIds.push(id);

          const isSentByCurrentUser = msg.uid === currentUser.uid;
          const isEdited = msg.editedAt ? true : false;
          const isReadByUser = msg.readBy?.includes(currentUser.uid) ?? false;

          const div = document.createElement("div");
          div.className = `max-w-[70%] px-4 py-2 rounded-lg shadow-sm break-words flex flex-col
            ${isSentByCurrentUser ? "bg-blue-600 text-white self-end rounded-tr-none" : "bg-gray-300 dark:bg-gray-700 text-gray-900 dark:text-gray-100 self-start rounded-tl-none"}`;

          let contentHTML = 
            `<div class="text-xs opacity-70 font-semibold">${msg.username}</div>` +
            (msg.text ? `<div>${escapeHTML(msg.text)}</div>` : "") +
            (msg.imageUrl ? `<img src="${msg.imageUrl}" class="mt-2 rounded shadow max-w-xs" />` : "") +
            (msg.audioUrl ? `<audio controls class="mt-2 rounded w-48" src="${msg.audioUrl}"></audio>` : "") +
            (isEdited ? `<div class="text-[10px] italic opacity-60 mt-1">edited</div>` : "");

          div.innerHTML = contentHTML;

          // Edit & Delete Buttons for current user's messages
          if (isSentByCurrentUser) {
            const actionsDiv = document.createElement("div");
            actionsDiv.className = "flex gap-2 mt-1 self-end";

            // Edit button
            const editBtn = document.createElement("button");
            editBtn.textContent = "‚úèÔ∏è";
            editBtn.title = "Edit message";
            editBtn.className = "text-xs hover:underline";
            editBtn.onclick = () => startEditingMessage(docSnap.id, msg.text);
            actionsDiv.appendChild(editBtn);

            // Delete button
            const delBtn = document.createElement("button");
            delBtn.textContent = "üóëÔ∏è";
            delBtn.title = "Delete message";
            delBtn.className = "text-xs hover:underline";
            delBtn.onclick = () => deleteMessage(docSnap.id);
            actionsDiv.appendChild(delBtn);

            div.appendChild(actionsDiv);
          }

          // Read receipt checkmark for sent messages
          if (isSentByCurrentUser) {
            const readReceipt = document.createElement("div");
            readReceipt.className = "text-xs self-end opacity-70 mt-1 flex items-center gap-1";
            const allRead = msg.readBy?.length >= 1 && msg.readBy.includes(currentUser.uid); // Simplified
            readReceipt.innerHTML = allRead 
              ? `<span title="Read">&#10003;&#10003;</span>` 
              : `<span title="Sent">&#10003;</span>`;
            div.appendChild(readReceipt);
          }

          messagesList.appendChild(div);
        });

        // Scroll to bottom
        messagesList.scrollTop = messagesList.scrollHeight;
      });

      // Update typing indicator listener
      listenToTyping(groupId);
    }

    // Escape HTML to prevent injection
    function escapeHTML(str) {
      if (!str) return "";
      return str.replace(/[&<>"']/g, function (match) {
        const escape = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        return escape[match];
      });
    }

    // Back to group list
    function backToGroups() {
      currentGroupId = null;
      if (messagesListener) messagesListener();
      messagesList.innerHTML = "";
      groupTitle.textContent = "";
      typingIndicator.textContent = "";
      document.getElementById("chatPage").classList.add("hidden");
      document.getElementById("groupsPage").classList.remove("hidden");
    }

    // Send a message (text, image, audio)
    async function sendMessage() {
      if (!currentGroupId) {
        alert("Please select a group first.");
        return;
      }
      const text = messageInput.value.trim();
      if (!text && !selectedImage && !recordedChunks.length) return;

      let imageUrl = null;
      if (selectedImage) {
        const storageRef = ref(storage, `images/${Date.now()}_${selectedImage.name}`);
        await uploadBytes(storageRef, selectedImage);
        imageUrl = await getDownloadURL(storageRef);
        selectedImage = null;
        document.getElementById("imageInput").value = "";
      }

      let audioUrl = null;
      if (recordedChunks.length) {
        const blob = new Blob(recordedChunks, { type: "audio/webm" });
        recordedChunks = [];
        const storageRef = ref(storage, `audio/${Date.now()}_voice.webm`);
        await uploadBytes(storageRef, blob);
        audioUrl = await getDownloadURL(storageRef);
        stopRecordingUI();
      }

      // Add message doc
      await addDoc(collection(db, "groups", currentGroupId, "messages"), {
        text,
        username: currentUser.displayName,
        uid: currentUser.uid,
        imageUrl,
        audioUrl,
        readBy: [currentUser.uid], // message is read by sender automatically
        createdAt: serverTimestamp(),
      });

      messageInput.value = "";
      updateTypingStatus(false);
    }

    // Image preview
    function previewImage(event) {
      selectedImage = event.target.files[0];
      if (selectedImage) {
        alert(`Image "${selectedImage.name}" selected! It will be sent with your next message.`);
      }
    }

    // Editing message
    let editingMessageId = null;
    function startEditingMessage(messageId, oldText) {
      editingMessageId = messageId;
      messageInput.value = oldText;
      messageInput.focus();
      messageInput.setSelectionRange(oldText.length, oldText.length);
      // Change send button to save
      document.querySelector("footer button.bg-blue-600").textContent = "Save";
      document.querySelector("footer button.bg-blue-600").onclick = saveEditedMessage;
    }
    async function saveEditedMessage() {
      if (!editingMessageId) return;
      const newText = messageInput.value.trim();
      if (!newText) return alert("Message cannot be empty");
      const msgDoc = doc(db, "groups", currentGroupId, "messages", editingMessageId);
      await updateDoc(msgDoc, {
        text: newText,
        editedAt: serverTimestamp(),
      });
      editingMessageId = null;
      messageInput.value = "";
      // Restore send button
      const sendBtn = document.querySelector("footer button.bg-blue-600");
      sendBtn.textContent = "Send";
      sendBtn.onclick = sendMessage;
    }

    // Delete message
    async function deleteMessage(messageId) {
      if (!confirm("Are you sure you want to delete this message?")) return;
      const msgDoc = doc(db, "groups", currentGroupId, "messages", messageId);
      await deleteDoc(msgDoc);
    }

    // Typing indicator logic
    async function updateTypingStatus(isTyping) {
      if (!currentGroupId || !currentUser) return;
      const typingDoc = doc(db, "groups", currentGroupId, "typing", currentUser.uid);
      if (isTyping) {
        await updateDoc(typingDoc, { name: currentUser.displayName }).catch(async () => {
          // If doc doesn't exist, create it
          await setDoc(typingDoc, { name: currentUser.displayName });
        });
      } else {
        await deleteDoc(typingDoc).catch(() => {});
      }
    }

    // Listen to typing indicator
    function listenToTyping(groupId) {
      const typingRef = collection(db, "groups", groupId, "typing");
      onSnapshot(typingRef, snapshot => {
        const typingUsers = [];
        snapshot.forEach(doc => {
          if (doc.id !== currentUser.uid) {
            typingUsers.push(doc.data().name);
          }
        });
        if (typingUsers.length === 0) {
          typingIndicator.textContent = "";
        } else if (typingUsers.length === 1) {
          typingIndicator.textContent = `${typingUsers[0]} is typing...`;
        } else {
          typingIndicator.textContent = `${typingUsers.join(", ")} are typing...`;
        }
      });
    }

    // Voice recording logic
    let mediaRecorder;
    let recordedChunks = [];
    recordBtn.addEventListener("click", () => {
      if (recordBtn.dataset.recording === "true") {
        stopRecording();
      } else {
        startRecording();
      }
    });
    async function startRecording() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        alert("Audio recording is not supported in your browser.");
        return;
      }
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = () => {
        // Recording stopped, ready to send audio message
      };
      mediaRecorder.start();
      recordBtn.textContent = "Stop Recording";
      recordBtn.dataset.recording = "true";
    }
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        recordBtn.textContent = "Record Voice";
        recordBtn.dataset.recording = "false";
      }
    }
    function stopRecordingUI() {
      recordBtn.textContent = "Record Voice";
      recordBtn.dataset.recording = "false";
    }

    // Event listeners for message input typing status
    messageInput.addEventListener("input", () => {
      updateTypingStatus(messageInput.value.length > 0);
    });

    // Send message on Enter key
    messageInput.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        if (editingMessageId) {
          saveEditedMessage();
        } else {
          sendMessage();
        }
      }
    });

    // Image input change
    document.getElementById("imageInput").addEventListener("change", previewImage);

    // Group create button
    document.getElementById("createGroupBtn").addEventListener("click", createGroup);

    // Back button
    document.getElementById("backBtn").addEventListener("click", backToGroups);

    // Send button
    document.querySelector("footer button.bg-blue-600").addEventListener("click", sendMessage);
  </script>
</body>
</html>
